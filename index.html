<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.js">

    </script>
    <style type='text/css'>
      *
      {
        margin: 0;
        padding: 0;
      }
      #world
      {
        background-color: black;
      }
    </style>
  </head>
  <body>

    <svg id='world' height='500' width='1000'>
    </svg>

  </body>
  <script type="text/javascript">

  (function(){

    var main_interval;

    function makeSVG(tag, attrs) {
      var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (var k in attrs)
      el.setAttribute(k, attrs[k]);
      return el;
    }

    function getTime(){
      var date = new Date();
      return date.getTime();
    }
    // ---------- END OF GLOBAL FUNCTIONS


    // ---------- HERO CONSTRUCTOR + METHODS

    // --- hero CONSTRUCTOR
    // -- constructs hero
    // -- data is hardcoded
    var Hero = function HeroConstructor(){
      this.info = {
        name: 'our_hero',
        x: 100,
        y: 410,
        height: 40,
        width: 20,
        jumping: null,
        j_strength: 25,
        j_start: null,
        j_decay: 0.2,
        velocity: {
          x: 0,
          y: 0
        }
      };
      this.current_time;
    };

    // --- hero draw
    // -- draws hero to HTML and creates SVG element
    // -- takes no input, works off of Hero object
    Hero.prototype.draw = function(){
      var hero_parts = {
        name: this.info.name,
        id: this.info.name,
        x: this.info.x,
        y: this.info.y,
        width: this.info.width,
        height: this.info.height,
        fill: 'red'
      }
      var temp = makeSVG('rect', hero_parts);
      document.getElementById('world').appendChild(temp);
    };

    // --- hero TIMER
    // -- used for jump calculation, constant timestamp
    Hero.prototype.timer = function(){
      this.current_time = getTime();
    }

    Hero.prototype.update = function(){
      var current_y = parseInt($('#' + this.info.name).attr('y'));

      if(this.info.jumping){

        var temp = (this.current_time - this.info.j_start) / 10;
        var temp2 = ((temp - 25) / 100) * -1;
        var temp3 = temp2 * 2;
        if(temp3 < 0.15){
          temp3 = 0.15;
        }
        this.info.j_decay = temp3;
      }

      this.info.velocity.y += this.info.j_decay;

      //console.log(this.info.j_decay);


      //$('#' + this.info.name).attr('x', current_x + this.info.velocity.x);
      $('#' + this.info.name).attr('y', current_y + this.info.velocity.y);
      this.info.y = current_y + this.info.velocity.y;
    };

    var World = function WorldConstructor(){
      //this.current_time;
      this.info = {
        height: 500,
        width: 1000,
        floor_counter: 1
      };

      this.floors = [
      {
        info: {
          name: 'floor0',
          id: 'floor0',
          x: 0,
          y: 450,
          height: 40,
          width: 1100,
          fill: 'green'
        },
        velocity: {
          x: 6
        },
        gap: 250,
        ungapped: true
      }
      ];

      var startpart = this.floors[0].info;
      var temp = makeSVG('rect', startpart);
      document.getElementById('world').appendChild(temp);
    }

    World.prototype.clear_all = function(){
      for(floor in this.floors){
        var cur = this.floors[floor];
        $('#' + cur.info.name).remove();
      }
    }

    Hero.prototype.clear_all = function(){
      $('#' + this.info.name).remove();
    }


    World.prototype.update = function(hero){
      for(floor in this.floors){
        //pre update numbers
        //console.log(this.floors[floor].gap);
        var cur = this.floors[floor];
        var floor_x = $('#' + cur.info.name).attr('x');
        var hero_y = $('#' + hero.info.name).attr('y');
        var hero_h = $('#' + hero.info.name).attr('height');

        //console.log(hero.info.velocity.y);
        //console.log(floor_x);

        // hero updates

        //actual updates
        $('#' + cur.info.name).attr('x', floor_x - cur.velocity.x);
        cur.info.x -= cur.velocity.x;

        //

        //creation check
        if(cur.ungapped){
          if(cur.info.x + cur.info.width + cur.gap < 1000){
            var new_floor = new Floor('floor' + this.info.floor_counter++);
            //console.log(new_floor.info);
            new_floor.draw();
            cur.ungapped = false;
            var gap_size = Math.floor(Math.random() * 151) + 100;
            //var random_speed = Math.floor(Math.random() * 4) + ;
            this.floors.push({info: new_floor.info, velocity: {x: 6}, gap: gap_size, ungapped: true})
            //  console.log(this.floors);
          }
        }
        //deletion check
        if(cur.info.x + cur.info.width + cur.gap <= 0){
          $('#' + cur.info.name).remove();
          this.floors.shift();
          //console.log(this.floors);
        }

        // floor check
        if(cur.info.x < 110 && cur.info.x + cur.info.width > 110){
          if(hero_y + hero_h > cur.info.y - cur.info.height && hero_y + hero_h < 450){
            hero.info.velocity.y = 0;
            $('#' + hero.info.name).attr('y', 410);
          }
        }

        if(hero.info.y > 500){
          console.log('DEADED');
          window.clearInterval(main_interval)
          main_interval++;
          document.onkeydown = function(e){
            if(e.keyCode === 32){
              //console.log('test');
              var new_hero = new Hero();
              var new_world = new World();
              Everything(new_hero, new_world);
              //console.log(Interval);
            }
          }
        }

        // gap check
        //console.log(cur.info.x + cur.info.width);
        // if(!(cur.info.x < 110) && !(cur.info.x + cur.info.width > 90)){
        //   console.log('TEST1');
        //   if(hero_y + hero_h > cur.info.y - cur.info.height){
        //     hero.info.velocity.y = 20;
        //     console.log('TEST2');
        //   }
        //   if(hero.info.velocity.y === 0){
        //     console.log('TEST3');
        //     hero.info.velocity.y = 20;
        //   }
        // }
        //var floor_x = $('#' + this.floors[floor].info.id)
      }
    }

    var Floor = function FloorConstructor(name){

      var rand_w = Math.floor(Math.random() * 451) + 50;

      this.info = {
        name: name,
        id: name,
        x: 1000,
        y: 450,
        height: 40,
        width: rand_w,
        fill: 'green'
      };
    }




    Floor.prototype.draw = function(){
      var startpart = this.info;
      //this.floors.push(startpart);
      var temp = makeSVG('rect', startpart);
      document.getElementById('world').appendChild(temp);
    }

    var Everything = function Everything(hero1, world1){


      hero1.draw();
      world1.update(hero1);
      //floor1.drawStart();


      function gameLoop(){
        hero1.timer();
        hero1.update();
        world1.update(hero1);
      }




      document.onkeydown = function(e){

        if(e.keyCode === 32){
          //console.log('test');
          //test++;
          if(!hero1.info.j_start){
            hero1.info.j_start = getTime();
          }
          //console.log(mousedown_time);
          if(!hero1.info.jumping){
            //mousedown_time = getTime();
            if(hero1.info.velocity.y == 0){
              //console.log('TEST')
              hero1.info.velocity.y = -10;
            }
            hero1.info.jumping = true;

          }
        }
      }

      document.onkeyup = function(e){

        if(e.keyCode === 32){

          hero1.info.jumping = null;
          hero1.info.j_start = null;

        }
      }

      main_interval = setInterval(gameLoop, 15);

      //console.log(interval);

    }

    var Interval;

    document.onkeydown = function(e){
      if(e.keyCode === 32){
        //console.log('test');
        var first_hero = new Hero();
        var first_world = new World();
        Everything(first_hero, first_world);
        //console.log(Interval);
      }
    }


  })();

  </script>
</html>
